# [[15] - 3Sum](https://leetcode.com/problems/3sum)

---

- Medium
- [Submission](https://leetcode.com/problems/3sum/submissions/900462248/)

### cpp
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        int n = nums.size();

        for (int i = 0; i < n - 2; ++i) {
            if (nums[i] > 0) break;

            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int s = i + 1;
            int e = n - 1;

            while (s < e) {
                int sum = nums[i] + nums[s] + nums[e];
                if (sum < 0) ++s;
                else if (sum > 0) --e;
                else {
                    ans.push_back({nums[i], nums[s], nums[e]});
                    while (s < e && nums[s] == nums[s + 1]) ++s;
                    ++s;
                    while (s < e && nums[e - 1] == nums[e]) --e;
                    --e;
                }
            }
        }

        return ans;
    }
};
```

---

## Notes

- This one's a little complicated. But it follows a similar logic to Two Sum II.
- Sort the array, and now for each element in the array, we perform a Two Sum II search, by using 2 pointers to see if the sum sums up to 0.
- Sorting is `O(nlogn)` and Searching is `O(n^2)`.
- Also have to keep in mind that we don't want the same repeating number to be used again. Hence after a match is found, we have to move the search pointers till the value is different from the previous value.
